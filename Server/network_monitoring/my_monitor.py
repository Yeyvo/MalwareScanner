from typing import List
from network_monitoring import Filter
from network_monitoring import Packet
import pyshark
import threading
import asyncio


class Monitor(threading.Thread):
    capture = True

    def __init__(self, network_interface: str, source_addr: str, filters: List[Filter], private_IPs: List[str], callback) -> None:
        threading.Thread.__init__(self)
        self._loop = asyncio.new_event_loop()
        self.network_interface = network_interface
        self.filters = filters
        self.callback = callback
        self.source_addr = source_addr
        self.private_ips = private_IPs

    def run(self):
        # self._loop.run_until_complete(self.monitor())
        # self._loop.run_forever()
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            loop.run_until_complete(self.monitor())
            loop.close()
        except Exception:
            pass

    def monitor(self):
        capture = True
        print("monitoring " + self.network_interface)
        # capture = pyshark.LiveCapture(interface=self.network_interface)
        filtre_src = ""
        filtre_dst = ""
        # for private_ip in self.private_ips:
        #     filtre_src += f" and ip.src_host != {private_ip}"
        #     filtre_dst += f" and ip.dst_host != {private_ip}"

        # filtre = f"(src host {self.source_addr[0]} or dst host {self.source_addr[0]}"
        # filtre = f"(ip.src_host == {self.source_addr[0]} {filtre_dst})  or (ip.dst_host == {self.source_addr[0]} {filtre_src})"

        # print("FILTER : " + filtre)
        filtre = "tcp or udp"
        # capture = pyshark.LiveCapture(interface=self.network_interface)
        capture = pyshark.LiveCapture(interface=self.network_interface,
                                      bpf_filter=filtre)  # or src host {self.source_addr[1]} or dst host {self.source_addr[1]}

        for raw_packet in capture.sniff_continuously():
            # try:
            # 		self.callback(raw_packet.tcp.payload)
            # except Exception:
            # 		pass
            # print(raw_packet)
            if not self.capture:
                capture.close()
            packet = self.format_packet(raw_packet)
            print(packet)
            # passes = True
            # for f in self.filters:
            #     if not f.filter(packet):
            #         passes = False
            #         break
            # if passes:
            #     self.callback(packet)
            self.callback(packet)

    def stop(self):
        self.capture = False

    def format_packet(self, raw_packet):

        protocol = raw_packet.transport_layer
        source_address = raw_packet.ip.src
        source_port = raw_packet[raw_packet.transport_layer].srcport
        destination_address = raw_packet.ip.dst
        destination_port = raw_packet[raw_packet.transport_layer].dstport
        packet_time = raw_packet.sniff_time

        return {
            "protocol": protocol,
            "source_addr": source_address,
            "source_port": source_port,
            "destination_addr": destination_address,
            "destination_port": destination_port,
            "packet_time": packet_time
        }

        # protocol = raw_packet.transport_layer
        # source_address = raw_packet.ip.src if hasattr(
        #     raw_packet, "ip") else None
        # source_port = 0
        # try:
        #     source_port = raw_packet[raw_packet.transport_layer].srcport
        # except Exception:
        #     source_port = -1
        #     pass
        # destination_address = raw_packet.ip.dst if hasattr(
        #     raw_packet, "ip") else None
        # destination_port = 0
        # try:
        #     destination_port = raw_packet[raw_packet.transport_layer].dstport
        # except Exception:
        #     destination_port = -1
        #     pass

        # return {
        #     "protocol": protocol,
        #     "source_addr": source_address,
        #     "source_port": source_port,
        #     "destination_addr": destination_address,
        #     "destination_port": destination_port
        # }
