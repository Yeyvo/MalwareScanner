from typing import List
from network_monitoring import Filter
from network_monitoring import Packet
import pyshark
import threading
import asyncio


class Monitor(threading.Thread):
    capture = True

    def __init__(self, network_interface: str, source_addr: str, filters: List[Filter], private_IPs: List[str], callback) -> None:
        threading.Thread.__init__(self)
        self._loop = asyncio.new_event_loop()
        self.network_interface = network_interface
        self.filters = filters
        self.callback = callback
        self.source_addr = source_addr
        self.private_ips = private_IPs

    def run(self):
        # self._loop.run_until_complete(self.monitor())
        # self._loop.run_forever()
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            loop.run_until_complete(self.monitor())
            loop.close()
        except Exception:
            pass

    def monitor(self):
        capture = True
        print("monitoring " + self.network_interface)
        # capture = pyshark.LiveCapture(interface=self.network_interface)
        filtre_src = ""
        filtre_dst = ""
        # for private_ip in self.private_ips:
        #     filtre_src += f" and ip.src_host != {private_ip}"
        #     filtre_dst += f" and ip.dst_host != {private_ip}"

        # filtre = f"(src host {self.source_addr[0]} or dst host {self.source_addr[0]}"
        # filtre = f"(ip.src_host == {self.source_addr[0]} {filtre_dst})  or (ip.dst_host == {self.source_addr[0]} {filtre_src})"

        # print("FILTER : " + filtre)
        filtre = "tcp"
        # capture = pyshark.LiveCapture(interface=self.network_interface)
        capture = pyshark.LiveCapture(interface=self.network_interface, use_json=True,
                                      )  # bpf_filter=filtre or src host {self.source_addr[1]} or dst host {self.source_addr[1]}

        for raw_packet in capture.sniff_continuously():
            # try:
            # 		self.callback(raw_packet.tcp.payload)
            # except Exception:
            # 		pass
            # print(raw_packet)
            if not self.capture:
                capture.close()
            packet = self.format_packet(raw_packet)
            # print(packet)
            # passes = True
            # for f in self.filters:
            #     if not f.filter(packet):
            #         passes = False
            #         break
            # if passes:
            #     self.callback(packet)
            asyncio.run(self.callback(packet))

    def stop(self):
        self.capture = False

    def format_packet(self, packet):

        # to avoid getting data from the header (encapsulation of traffic mirroring)
        # TODO change capture mode from json to XML and then change this to 5
        start_index_papcket = 1
        end_index_papcket = len(packet.layers)
        res = {}

        for i in range(start_index_papcket, end_index_papcket):
            # print(packet.layers[i]._full_name, end=" ->")
            if (packet.layers[i]._full_name == "ip"):

                res['src_host'] = packet.layers[i]._all_fields['ip.src_host']
                res['dst_host'] = packet.layers[i]._all_fields['ip.dst_host']

            elif (packet.layers[i]._full_name == "ipv6"):
                res['src_host'] = packet.layers[i]._all_fields['ipv6.src_host']
                res['dst_host'] = packet.layers[i]._all_fields['ipv6.dst_host']

            elif (packet.layers[i]._full_name == "arp"):
                res['src.hw_mac'] = packet.layers[i]._all_fields['arp.src.hw_mac']
                res['dst.hw_mac'] = packet.layers[i]._all_fields['arp.dst.hw_mac']

            elif (packet.layers[i]._full_name == "udp"):
                res['srcport'] = packet.layers[i]._all_fields['udp.srcport']
                res['dstport'] = packet.layers[i]._all_fields['udp.dstport']
                if 'udp.payload' in packet.layers[i]._all_fields:
                    res['payload'] = packet.layers[i]._all_fields['udp.payload']

            elif (packet.layers[i]._full_name == "tcp"):
                res['srcport'] = packet.layers[i]._all_fields['tcp.srcport']
                res['dstport'] = packet.layers[i]._all_fields['tcp.dstport']
                if 'tcp.payload' in packet.layers[i]._all_fields:
                    res['payload'] = packet.layers[i]._all_fields['tcp.payload']
            else:
                res['protocol'] = str.upper(packet.layers[i]._full_name)

        return res
