from aiohttp import web
import socketio
import uuid
import util
import asyncio
from network_monitoring import Monitor, Filter
import util.aws_utils as aws_utils
sio = socketio.AsyncServer(cors_allowed_origins='*')

app = web.Application()

sio.attach(app)

initial_infrastructure_data = None

# store contains pointers to monitors
# format: sid <==> {"monitor" : monitor, "vm_id": id}
# for now each user must have only one monitor, therefore one vm
# when creating a vm we must check if the sid already exists
# if it exists we refuse to create another vm
# unless the user send a force flag, then we close the running vm and create another one
# else if the sid doesn't exists in the store then we create the vm and create a monitor and add it to the store
# when the user stops a malware test, we close the monitor associated to it in the store and remove the sid key
# TODO: when the user disconnects, if his sid exists in the store we close the monitor associated to him and we stop the vm (we must also store the vm id)
store = {}

# the events we support
# from client to server : test_malware, stop
# from server to client : visited_ip (contains ip and port)


@sio.on('test_malware')
async def test_malware(sid, message):
    # check if user already has a vm running and he didn't send the force flag
    if store.get(sid):

        if not message.get("force"):
            await sio.emit('info', {
                "status": "can't test more than one malware"
            }, room=sid)
            return
        await sio.emit('info', {
            "status": f"forcing existing sandbox : {store.get(sid).get('vm_information')['instance_id']} to turn off"
        }, room=sid)
        store.get(sid).get("monitor").stop()
        store.pop(sid, None)

    url = message.get("url")
    sio.emit('info', {
        'status': 'creating',
        'url': url
    }, room=sid)
    # FIXME: return info about the created vm (ip adress ...)
    creation_result = await util.create_vm(initial_data=initial_infrastructure_data, malware_url=url)

    addrresses = [creation_result['publicIP'], creation_result['privateIP']]

    def callback(packet):

        protocol = packet.get("protocol")
        source_addr = packet.get("source_addr")
        source_port = packet.get("source_port")
        destination_addr = packet.get("destination_addr")
        destination_port = packet.get("destination_port")
        # if destination_addr:
        #     sio.emit('visited_ip', {
        #         "dest_ip": destination_addr,
        #         "dest_port": destination_port,
        #         "transport_layer_protocol": protocol
        #     }, room=sid)
        sio.emit('visited_ip', {
            "src_ip": source_addr,
            "src_port": source_port,
            "dest_ip": destination_addr,
            "dest_port": destination_port,
            "protocol": protocol
        }, room=sid)

    # figure out how to stop monitor (where to store ref to monitor)

    network_interface = "eth1"
    # FIXME: is source_addr variable still there ?
    monitor = Monitor(network_interface, source_addr=addrresses,
                      filters=[], callback=callback)
    print("inserting into store")
    store[sid] = {
        "monitor": monitor,
        "vm_information": creation_result
    }
    print(store)
    await sio.emit('info', {
        'status': 'running malware',
        'id': creation_result['instance_id'],
        'url': url
    }, room=sid)
    monitor.monitor()


@sio.on('stop')
async def stop_malware(sid, message):
    # check if user has a malware test running
    print(store)
    if not store.get(sid):
        # user does not have a malware test running
        await sio.emit('info', {
            "status": f"you do not have any running malware"
        }, room=sid)

    # stop the monitoring too
    vm_information = store.get(sid).get('vm_information')

    await sio.emit('info', {
        "status": f"forcing existing sandbox : {store.get(sid).get('vm_information')['instance_id']} to turn off"
    }, room=sid)
    store.get(sid).get("monitor").stop()
    store.pop(sid, None)

    await sio.emit('info', {
        'status': 'shutting down',
        'id': vm_information['instance_id']
    }, room=sid)

    # FIXME: return final status of the vm (off)
    await util.stop_vm(instance_id=vm_information['instance_id'], mirror_data=vm_information['mirror_data'], initial_data=initial_infrastructure_data)

    await sio.emit('info', {
        'status': 'off',
        'id': vm_information['instance_id']
    }, room=sid)

# TODO: stop vms when user disconects


@sio.event
async def disconnect(sid):
    print('disconnect ', sid)

    # checking if this user has any running malware tests
    if store.get(sid):
        await sio.emit('info', {
            "status": f"forcing existing sandbox : {store.get(sid).get('vm_id')} to turn off"
        }, room=sid)

        vm_id = store.get(sid).get('vm_id')
        # stop and destroy the monitoring object
        store.get(sid).get("monitor").stop()
        store.pop(sid, None)
        # stop the vm
        await util.stop_vm(name=vm_id)

if __name__ == '__main__':
    initial_infrastructure_data = aws_utils.getInitialData()
    web.run_app(app, port=8081)
