import boto3
import paramiko
import socket


def delete_mirror_session_by_id(ec2_ressource, mirror_session_id: str) -> None:
    ec2_ressource.meta.client.delete_traffic_mirror_session(
        TrafficMirrorSessionId=mirror_session_id,
    )


def delete_mirror_filter_id_by_id(ec2_ressource, mirror_filter_id: str, mirror_filter_rules: list[str]) -> None:
    for mirror_filter_rule_id in mirror_filter_rules:
        ec2_ressource.meta.client.delete_traffic_mirror_filter_rule(
            TrafficMirrorFilterRuleId=mirror_filter_rule_id
        )

    ec2_ressource.meta.client.delete_traffic_mirror_filter(
        TrafficMirrorFilterId=mirror_filter_id
    )


def delete_mirror_target_by_id(ec2_ressource, mirror_target_id: str) -> None:

    ec2_ressource.meta.client.delete_traffic_mirror_target(
        TrafficMirrorTargetId=mirror_target_id
    )


def terminate_ec2_by_id(ec2_ressource, instance_id: str) -> None:

    instance = ec2_ressource.Instance(instance_id)
    instance.terminate()
    print(f'Terminating EC2 instance: {instance.id}')
    instance.wait_until_terminated()


def create_mirror_target(ec2_ressource, target_eni_id):

    return ec2_ressource.meta.client.create_traffic_mirror_target(
        NetworkInterfaceId=target_eni_id
    )['TrafficMirrorTarget']['TrafficMirrorTargetId']


def create_mirror_filter(ec2_ressource):

    filter_id = ec2_ressource.meta.client.create_traffic_mirror_filter(
    )['TrafficMirrorFilter']['TrafficMirrorFilterId']

    rules_id = []

    resp = ec2_ressource.meta.client.create_traffic_mirror_filter_rule(
        TrafficMirrorFilterId=filter_id,
        TrafficDirection='ingress',
        RuleNumber=1,
        RuleAction='accept',
        DestinationCidrBlock='0.0.0.0/0',
        SourceCidrBlock='0.0.0.0/0'
    )

    # print(resp)
    rules_id.append(resp['TrafficMirrorFilterRule']
                    ['TrafficMirrorFilterRuleId'])

    resp = ec2_ressource.meta.client.create_traffic_mirror_filter_rule(
        TrafficMirrorFilterId=filter_id,
        TrafficDirection='egress',
        RuleNumber=1,
        RuleAction='accept',
        DestinationCidrBlock='0.0.0.0/0',
        SourceCidrBlock='0.0.0.0/0'
    )
    # rules_id.append(resp['TrafficMirrorFilterRule']
    #                 ['TrafficMirrorFilterRuleId'])

    return filter_id, rules_id


def create_mirror_session(ec2_ressource, mirror_target_id, mirror_filter_id, network_interface_id):

    return ec2_ressource.meta.client.create_traffic_mirror_session(
        NetworkInterfaceId=network_interface_id,
        # NetworkInterfaceId=instance['NetworkInterfaces'][0]['NetworkInterfaceId'],
        TrafficMirrorTargetId=mirror_target_id,
        TrafficMirrorFilterId=mirror_filter_id,
        SessionNumber=1
    )['TrafficMirrorSession']['TrafficMirrorSessionId']


def getSecurityGroupID(ec2_ressource, malware_sandboxed_VPC_id: str) -> str:
    SecurityGroup = ec2_ressource.meta.client.describe_security_groups(

        Filters=[{"Name": "tag:Name", "Values": ["Malware_Env_Security_Group"]}]
    )
    return SecurityGroup['SecurityGroups'][0]["GroupId"]


def getSubnetID(ec2_ressource, malware_sandboxed_VPC_id: str) -> str:
    subnets = ec2_ressource.subnets.filter(
        Filters=[{"Name": "vpc-id", "Values": [malware_sandboxed_VPC_id]}]
    )
    subnet_ids = [sn.id for sn in subnets]
    return subnet_ids[0]


def getVpcID(ec2_ressource, vpc_name: str, cidr_block: str) -> str:

    malware_sandboxed_VPC = ec2_ressource.meta.client.describe_vpcs(
        Filters=[
            {
                'Name': 'tag:Name',
                'Values': [
                    vpc_name,
                ]
            },
            {
                'Name': 'cidr-block-association.cidr-block',
                'Values': [
                    cidr_block,
                ]
            },
        ]
    )

    malware_sandboxed_VPC = malware_sandboxed_VPC['Vpcs']

    malware_sandboxed_VPC_id = malware_sandboxed_VPC[0]["VpcId"]

    return malware_sandboxed_VPC_id


def getInstanceIdAndNetworkInterfaceID(ec2_ressource, instance_name: str) -> str:
    instances = ec2_ressource.meta.client.describe_instances(
        Filters=[
            {
                'Name': 'tag:Name',
                'Values': [
                    instance_name
                ]

            },
            {
                'Name': 'instance-state-name',
                'Values': ['running']
            }
        ]
    )
    print(instances)
    return instances["Reservations"][0]['Instances'][0]['InstanceId'], instances["Reservations"][0]['Instances'][0]['NetworkInterfaces'][0]['NetworkInterfaceId']


def execute_commands_instances_ssh(commands: list[str], instance_ips: list[str], initial_keyname_path):

    for ip in instance_ips:
        # Connect
        client = paramiko.SSHClient()
        # client.load_system_host_keys()
        # client.connect('example.com', username='ubuntu', password='secret')

        try:
            client.connect(ip, 22, username='ubuntu',
                           key_filename=initial_keyname_path)
            print("Success!! -- Server: ")
            for command in commands:
                stdin, stdout, stderr = client.exec_command(command)
            print(type(stdin))  # <class 'paramiko.channel.ChannelStdinFile'>
            print(type(stdout))  # <class 'paramiko.channel.ChannelFile'>
            print(type(stderr))  # <class 'paramiko.channel.ChannelStderrFile'>

            # # Optionally, send data via STDIN, and shutdown when done
            # stdin.write('<?php echo "Hello!"; sleep(2); ?>')
            # stdin.channel.shutdown_write()

            # # Print output of command. Will wait for command to finish.
            print(f'STDOUT: {stdout.read().decode("utf8")}')
            print(f'STDERR: {stderr.read().decode("utf8")}')

            # # Get return code from command (0 is default for success)
            print(f'Return code: {stdout.channel.recv_exit_status()}')

            # Because they are file objects, they need to be closed
            stdin.close()
            stdout.close()
            stderr.close()

            # Close the client itself
            client.close()

        except paramiko.AuthenticationException:
            print("Authentication problem   -- Server: ")
            # exit(-11)
            continue
        except socket.error as e:
            print(f"Comunication problem {e}")
            # exit(-11)
            continue

        # Run a command (execute PHP interpreter)


def execute_commands_instances(ec2_ressource, commands: list[str], instance_ids: list[str], isLinuxInstance: bool):
    """Runs commands on remote instances
    :param client: a boto/boto3 ssm client
    :param commands: a list of strings, each one a command to execute on the instances
    :param instance_ids: a list of instance_id strings, of the instances on which to execute the command
    :return: the response from the send_command function (check the boto3 docs for ssm client.send_command() )
    """
    document_name = "AWS-RunPowerShellScript"
    if isLinuxInstance:
        document_name = "AWS-RunShellScript"

    # session = boto3.Session(profile_name='exampleaws')
    print(instance_ids)

    ssm_client = boto3.client('ssm')
    print("####################################################################################################################################################################################################################################****")
    print(ssm_client.describe_instance_information()
          ['InstanceInformationList'])
    print("####################################################################################################################################################################################################################################****")

    response = ssm_client.send_command(
        InstanceIds=instance_ids,
        DocumentName=document_name,
        Parameters={
            'commands': commands
        },
    )
    command_id = response['Command']['CommandId']
    output = ssm_client.get_command_invocation(
        CommandId=command_id,
        InstanceId=instance_ids,
    )
    # print("****************************************************************")
    # print(output)
    # print("****************************************************************")

    # resp = ec2_ressource.meta.client.send_command(
    #     DocumentName=document_name,  # One of AWS' preconfigured documents
    #     Parameters={'commands': commands},
    #     InstanceIds=instance_ids,
    # )
    return response


def getMirrorTargetIdByName(ec2_ressource, name):
    response = ec2_ressource.meta.client.describe_traffic_mirror_targets(

        Filters=[
            {
                'Name': 'tag:Name',
                'Values': [
                    name,
                ]
            },
        ]
    )
    return response['TrafficMirrorTargets'][0]['TrafficMirrorTargetId']


def getInitialData():
    ec2_ressource = boto3.resource('ec2', region_name='us-west-2')
    initial_data = {}

    initial_data['MAIN_SERVER_INSTANCE_ID'], initial_data['MAIN_SERVER_NETWORK_INTERFACE_ID'] = getInstanceIdAndNetworkInterfaceID(
        ec2_ressource, "mainbSanbServer")
    initial_data['VPC_ID'] = getVpcID(
        ec2_ressource, 'Malware_Env_VPC', '10.1.0.0/18')
    initial_data['SUBNET_ID'] = getSubnetID(
        ec2_ressource, initial_data['VPC_ID'])
    initial_data['SECURITY_GROUP_ID'] = getSecurityGroupID(
        ec2_ressource, "Malware_Env_Security_Group")

    initial_data["mirror_target_id"] = getMirrorTargetIdByName(
        ec2_ressource, "mainbSanbServer_mirrorTarget")

    initial_data['INSTANCE_TYPE'] = 't3.micro'  # t2.micro
    initial_data['ISNITRO'] = True

    initial_data['IS_LINUX_INSTANCE'] = True
    initial_data['AMI'] = "ami-0e6dff8bde9a09539"

    initial_data['MALWARE_SANDBOXED_KEYNAME'] = "MalwareSanbServer_private_key"
    initial_data['MALWARE_SANDBOXED_KEYNAME_PATH'] = "../.ssh/MalwareSanbServer_private_key.pem"

    initial_data['MALWARE_SERVER_ONLAUNCH_COMMAND'] = ['echo "hello world"']

    print("****************************************************")
    print("initial_data: {}".format(initial_data))
    print("****************************************************")

    return initial_data
